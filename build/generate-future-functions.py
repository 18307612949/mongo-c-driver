#!/usr/bin/env python
#
# Copyright 2015 MongoDB, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Generate test functions for use with mock_server_t.

Defines functions like future_cursor_next in future-functions.h and
future-functions.c, which defer a libmongoc operation to a background thread
via functions like background_mongoc_cursor_next. Also defines functions like
future_value_set_bson_ptr and future_value_get_bson_ptr which support the
future / background functions.

These future functions are used in conjunction with mock_server_t to
conveniently test libmongoc wire protocol operations.

Written for Python 2.6+, requires Jinja 2 for templating.
"""

from collections import namedtuple
from os.path import basename, dirname, join as joinpath, normpath

from jinja2 import Template  # Please "pip install jinja2".


mock_server_dir = normpath(joinpath(dirname(__file__), '../tests/mock_server'))

type_list = [
    'bool',
    'bson_error_ptr',
    'bson_ptr',
    'const_bson_ptr_ptr',
    'char_ptr_ptr',
    'mongoc_bulk_operation_ptr',
    'mongoc_client_ptr',
    'mongoc_cursor_ptr',
    'mongoc_database_ptr',
    'uint32_t',
]

header_comment = """/**************************************************
 *
 * Generated by build/%s.
 *
 * DO NOT EDIT THIS FILE.
 *
 *************************************************/""" % basename(__file__)


def write_file(file_name, template):
    print(file_name)
    with open(joinpath(mock_server_dir, file_name), 'w+') as f:
        f.write(Template(template).render(globals()))


write_file("future.h", """#ifndef FUTURE_H
#define FUTURE_H

#include <bson.h>

#include "future-value.h"
#include "mongoc-thread-private.h"

{{ header_comment }}

typedef struct
{
   bool             resolved;
   future_value_t   return_value;
   int              argc;
   future_value_t  *argv;
   mongoc_cond_t    cond;
   mongoc_mutex_t   mutex;
   mongoc_thread_t  thread;
} future_t;

future_t *future_new (future_value_type_t return_type, int argc);

future_t *future_new_copy (future_t *future);

future_value_t *future_get_param (future_t *future, int i);

void future_start (future_t *future,
                   void *(*start_routine)(void *));

void future_resolve (future_t *future, future_value_t return_value);

bool future_wait (future_t *future);

{% for T in type_list %}
{{ T }}
future_get_{{ T }} (future_t *future);
{% endfor %}

void future_destroy (future_t *future);

#endif /* FUTURE_H */
""")


write_file("future.c", """
#include <stdio.h>

#include "mongoc-array-private.h"
#include "mongoc-thread-private.h"
#include "future.h"

{{ header_comment }}

#define FUTURE_TIMEOUT_MS 10 * 1000

{% for T in type_list %}
{{ T }}
future_get_{{ T }} (future_t *future)
{
   if (future_wait (future)) {
      return future_value_get_{{ T }} (&future->return_value);
   }

   fprintf (stderr, "%s timed out\\n", __FUNCTION__);
   abort ();
}
{% endfor %}

future_t *
future_new (future_value_type_t return_type, int argc)
{
   future_t *future;

   future = bson_malloc0 (sizeof *future);
   future->return_value.type = return_type;
   future->argc = argc;
   future->argv = bson_malloc0 ((size_t) argc * sizeof(future_value_t));
   mongoc_cond_init (&future->cond);
   mongoc_mutex_init (&future->mutex);

   return future;
}

future_value_t *
future_get_param (future_t *future, int i)
{
   return &future->argv[i];
}

future_t *
future_new_copy (future_t *future)
{
   future_t *copy;

   mongoc_mutex_lock (&future->mutex);
   copy = future_new (future->return_value.type, future->argc);
   copy->return_value = future->return_value;
   memcpy (copy->argv, future->argv, future->argc * sizeof(future_value_t));
   mongoc_mutex_unlock (&future->mutex);

   return copy;
}


void
future_start (future_t *future,
              void *(*start_routine)(void *))
{
   int r = mongoc_thread_create (&future->thread,
                                 start_routine,
                                 (void *) future);

   assert (!r);
}


void
future_resolve (future_t *future, future_value_t return_value)
{
   mongoc_mutex_lock (&future->mutex);
   assert (!future->resolved);
   assert (future->return_value.type == return_value.type);
   future->return_value = return_value;
   future->resolved = true;
   mongoc_cond_signal (&future->cond);
   mongoc_mutex_unlock (&future->mutex);
}


bool
future_wait (future_t *future)
{
   /* TODO: configurable timeout */
   int64_t deadline = bson_get_monotonic_time () + FUTURE_TIMEOUT_MS * 1000;
   bool resolved;

   mongoc_mutex_lock (&future->mutex);
   while (!future->resolved && bson_get_monotonic_time () <= deadline) {
      mongoc_cond_timedwait (&future->cond, &future->mutex, FUTURE_TIMEOUT_MS);
   }
   resolved = future->resolved;
   mongoc_mutex_unlock (&future->mutex);

   return resolved;
}


void
future_destroy (future_t *future)
{
   bson_free (future->argv);
   mongoc_cond_destroy (&future->cond);
   mongoc_mutex_destroy (&future->mutex);
   bson_free (future);
}

""")


write_file("future-value.h", """#ifndef FUTURE_VALUE_H
#define FUTURE_VALUE_H

#include <bson.h>
#include <mongoc.h>

{{ header_comment }}

typedef char **char_ptr_ptr;
typedef mongoc_bulk_operation_t *mongoc_bulk_operation_ptr;
typedef mongoc_client_t *mongoc_client_ptr;
typedef mongoc_cursor_t *mongoc_cursor_ptr;
typedef mongoc_database_t *mongoc_database_ptr;
typedef bson_t *bson_ptr;
typedef const bson_t **const_bson_ptr_ptr;
typedef bson_error_t *bson_error_ptr;

typedef enum {
   future_value_no_type = 0,
{% for T in type_list %}   future_value_{{ T }}_type,
{% endfor %}
} future_value_type_t;

typedef struct _future_value_t
{
   future_value_type_t type;
   union {
{% for T in type_list %}      {{ T }} {{ T }}_value;
{% endfor %}
   };
} future_value_t;

future_value_t *future_value_new ();

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"
#endif

{% for T in type_list %}
void
future_value_set_{{ T }}(
   future_value_t *future_value,
   {{ T }} value);

{{ T }}
future_value_get_{{ T }} (
   future_value_t *future_value);
{% endfor %}

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#endif /* FUTURE_VALUE_H */
""")


write_file("future-value.c", """#include "future-value.h"

{{ header_comment }}

future_value_t *
future_value_new ()
{
   return (future_value_t *) bson_malloc0 (sizeof (future_value_t));
}

{% for T in type_list %}

void
future_value_set_{{ T }}(future_value_t *future_value, {{ T }} value)
{
  future_value->type = future_value_{{ T }}_type;
  future_value->{{ T }}_value = value;
}

{{ T }}
future_value_get_{{ T }} (future_value_t *future_value)
{
  assert (future_value->type == future_value_{{ T }}_type);
  return future_value->{{ T }}_value;
}

{% endfor %}
""")


param = namedtuple("param", ["type_name", "name"])
future_function = namedtuple("future_function", ["ret_type", "name", "params"])

future_functions = [
    future_function("uint32_t",
                    "bulk_operation_execute",
                    [param("mongoc_bulk_operation_ptr", "bulk"),
                     param("bson_ptr", "reply"),
                     param("bson_error_ptr", "error")]),

    future_function("bool",
                    "cursor_next",
                    [param("mongoc_cursor_ptr", "cursor"),
                     param("const_bson_ptr_ptr", "doc")]),

    future_function("char_ptr_ptr",
                    "client_get_database_names",
                    [param("mongoc_client_ptr", "client"),
                     param("bson_error_ptr", "error")]),

    future_function("char_ptr_ptr",
                    "database_get_collection_names",
                    [param("mongoc_database_ptr", "database"),
                     param("bson_error_ptr", "error")]),
]

write_file("future-functions.h", """#ifndef future_functionS_H
#define future_functionS_H

#include "future-value.h"
#include "future.h"
#include "mongoc-bulk-operation.h"

{{ header_comment }}

{% for F in future_functions %}
future_t *
future_{{ F.name }} (
{% for P in F.params %}
   {{ P.type_name }} {{ P.name }}{% if not loop.last %},{% endif %}{% endfor %}
);

{% endfor %}

#endif /* future_functionS_H */
""")


write_file("future-functions.c", """
/*
 * Define two sets of functions. A function in the first set, like
 * background_mongoc_cursor_next, runs a driver operation on a background
 * thread. One in the second set, like future_mongoc_cursor_next, launches
 * the background operation and returns a future_t that will resolve when
 * the operation finishes.
 *
 * These are used with mock_server_t so you can run the driver on a thread
 * while controlling the server from the main thread.
 */

#include "future-functions.h"

{% for F in future_functions %}
static void *
background_{{ F.name }} (void *data)
{
   future_t *future = (future_t *) data;

   /* copy the future so we can unlock it while calling
    * {{ F.name }}
    */
   future_t *copy = future_new_copy (future);
   future_value_t return_value;

   return_value.type = future_value_{{ F.ret_type }}_type;
 
   future_value_set_{{ F.ret_type }} (
      &return_value,
      mongoc_{{ F.name }} (
{% for P in F.params %}
         future_value_get_{{ P.type_name }} (future_get_param(copy, {{ loop.index0 }})){% if not loop.last %},{% endif %}{% endfor %}
   ));
 
   future_destroy (copy);
   future_resolve (future, return_value);
 
   return NULL;
}
{% endfor %}

{% for F in future_functions %}
future_t *
future_{{ F.name }} ({% for P in F.params %}
   {{ P.type_name }} {{ P.name }}{% if not loop.last %},{% endif %}{% endfor %})
{
   future_t *future = future_new (future_value_{{ F.ret_type }}_type,
                                  {{ F.params | length }});
   {% for P in F.params %}
   future_value_set_{{ P.type_name }} (
      future_get_param (future, {{ loop.index0 }}), {{ P.name }});
   {% endfor %}
   future_start (future, background_{{ F.name }});
   return future;
}
{% endfor %}
""")
