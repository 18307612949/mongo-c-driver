<?xml version="1.0"?>
<page id="tutorial"
      type="topic"
      xmlns="http://projectmallard.org/1.0/">

  <info>
    <link type="guide" xref="index#getting-started" />
  </info>

  <title>MongoDB C Driver Tutorial</title>

  <p>This page provides you with a little help getting started with the MongoDB C driver.</p>
  <p>For more information on the C API, please refer to the <link href="http://api.mongodb.org/c/current/">API Documentation</link>.</p>

  <section id="installation">
    <title>Installing</title>
    <p>Please see our <link xref="installing">installation guide</link> for details on how to install the MongoDB C Driver on your own platform.</p>
  </section>

  <section id="starting-mongod">
    <title>Starting MongoDB</title>
    <p>Before continuing with the examples, ensure that you have installed MongoDB and have it running on <code>localhost</code> on the default port, 27017. You can test that MongoDB is up and running by connecting to it with the MongoDB shell.</p>

    <screen><output style="prompt">$ mongo --host localhost --port 27017
MongoDB shell version: 3.0.6
connecting to: localhost:27017/test
> </output></screen>
  </section>

  <section id="connecting">
    <title>Making a Connection</title>
    <p>The C Driver provides a convenient way to access MongoDB regardless of your cluster configuration. It will handle connecting to single servers, replica sets and sharded clusters.</p>
    <p>In the following, we will create a new <link xref="mongoc_client_t">mongoc_client_t</link> that will be used to connect to <code>localhost:27017</code>:</p>

    <screen><code><![CDATA[#include <mongoc.h>

int
main (int   argc,
      char *argv[])
{
   mongoc_client_t *client;

   mongoc_init();

   /* Create a new client instance */
   client = mongoc_client_new ("mongodb://localhost:27017");

   /* Pretend to do work... */

   /* Release the client when finished */
   mongoc_client_destroy (client);

   return EXIT_SUCCESS;
}
]]></code></screen>

    <p>If we save our code as <code>test.c</code>, we can compile it like so:</p>
    <screen><output style="prompt">$ gcc -o test1 test.c $(pkg-config --cflags --libs libmongoc-1.0)</output></screen>

    <p>Alternatively, if you don't have <link href="http://www.freedesktop.org/wiki/Software/pkg-config/">pkg-config</link> on your system, you can manually manage your own include paths and libraries.</p>
    <screen><output style="prompt">$ gcc -o test1 test.c -I/usr/local/include -lmongoc-1.0 -lbson-1.0</output></screen>

    <p>It is important to note that creating a new instance of <code>mongoc_client_t</code> does not immediately connect to your MongoDB instance. This is performed lazily as needed.</p>

    <section id="connecting-replica-set">
      <title>Connecting to a Replica Set</title>
      <p>To connect to a replica set, specify the replica set name using the <code>?replicaSet=mysetname</code> URI option. You can also specify a seed list if you would like to be able to connect to multiple nodes in the case that one is down when initializing the connection.</p>

      <screen><code><![CDATA[mongoc_uri_t *uri = mongoc_uri_new ("mongodb://host1:27017,host2:27017/?replicaSet=mysetname");]]></code></screen>
    </section>

    <section id="connecting-sharded-cluster">
      <title>Connecting to a Sharded Cluster</title>
      <p>Connecting to a sharded cluster is just like connecting to a replica set, except you do not need to specify a replica set name. Simply specify the <code>mongos</code> instances you want to connect to:</p>

      <screen><code><![CDATA[mongoc_uri_t *uri = mongoc_uri_new ("mongodb://host1:27017,host2:27017/");]]></code></screen>
    </section>

    <section id="connecting-unix-socket">
      <title>Connecting to a Unix Domain Socket</title>
      <p>You can specify a path to a Unix domain socket instead of an IPv4 or IPv6 address. Simply pass the path to the socket. The socket path <strong>MUST</strong> end in <code>.sock</code>.</p>

      <screen><code><![CDATA[mongoc_uri_t *uri = mongoc_uri_new ("mongodb:///tmp/mysocket.sock");]]></code></screen>
    </section>

    <section id="connecting-ipv6">
      <title>Connecting to an IPv6 Address</title>
      <p>The MongoDB C Driver will automatically resolve IPv6 addresses from host names. However, if you would like to specify the IPv6 address directly, wrap the address in <code>[]</code>.</p>

      <screen><code><![CDATA[mongoc_uri_t *uri = mongoc_uri_new ("mongodb://[::1]:27017");]]></code></screen>
    </section>

    <section id="authentication">
      <title>Authentication</title>
      <p>If you would like to use authentication with your MongoDB instance, you can simply provide the credentials as part of the URI string.</p>

      <screen><code><![CDATA[mongoc_uri_t *uri = mongoc_uri_new ("mongodb://username:password@localhost/");]]></code></screen>
    </section>

    <section id="ssl">
      <title>SSL</title>
      <p>To enable SSL from your client, simply add the <code>?ssl=true</code> option to the URI.</p>

      <screen><code><![CDATA[mongoc_uri_t *uri = mongoc_uri_new ("mongodb://localhost/?ssl=true");]]></code></screen>
    </section>

    <section id="kerberos">
      <title>Kerberos</title>
      <p>If you are one of the people on planet Earth lucky enough to use Kerberos, you can enable that simply with the following URI. Note the secaping of the principal as it would duplicate the <code>@</code> sign in the URI.</p>

      <screen><code><![CDATA[mongoc_uri_t *uri = mongoc_uri_new ("mongodb://user%40realm.cc@localhost:27017/?authmechanism=GSSAPI");]]></code></screen>
    </section>

    <section id="additional-connection-options">
      <title>Additional Connection Options</title>
      <p>You can see the full variery of connection URI options <link href="http://docs.mongodb.org/manual/reference/connection-string/">here</link>.</p>
    </section>
  </section>

  <section id="getting-a-database">
    <title>Getting a Database or Collection</title>
    <p>Now that we have a client, we can fetch a handle to the collection or database using the following:</p>

    <screen><code><![CDATA[mongoc_collection_t *collection;
mongoc_database_t   *database;

database = mongoc_client_get_database (client, "test");
collection = mongoc_client_get_collection (client, "test", "test");

mongoc_collection_destroy (collection);
mongoc_database_destroy (database);
]]></code></screen>

  <p>Keep in mind that these functions return newly allocated structures, and therefore they need to be released with <link xref="mongoc_collection_destroy">mongoc_collection_destroy()</link> and <link xref="mongoc_database_destroy">mongoc_database_destroy()</link> when we are done using them</p>
  </section>

  <section id="creating-bson-documents">
    <title>Creating BSON Documents</title>
    <p>There are two ways to create BSON documents: building a <code>bson_t</code> imperatively field-by-field, or using BCON.</p>
    
    <section id="appending">
      <title>Appending BSON</title>
      <p>The imperative way of creating BSON makes use of libbson's append functions to construct a document. In this model, we initialize a <link href="http://api.mongodb.org/libbson/current/bson_t.html">bson_t</link> and then add fields to it one at a time.</p>

      <screen><code><![CDATA[#include <bson.h>

bson_t *b;

/*
 * Append {"hello" : "world"} to the document.
 * The -1 indicates that the string is \0-terminated.
 */
bson_append_utf8 (b, "hello", -1, "world", -1);

/*
 * For convenience, you can use this macro, which is equivalent and saves characters.
 */
BSON_APPEND_UTF8 (b, "hello", "world");

/*
 * Let's build a sub-document.
 */
bson_t child;

BSON_APPEND_DOCUMENT_BEGIN (b, "subdoc", &child);
BSON_APPEND_UTF8 (&child, "subkey", "value");
bson_append_document_end (b, &child);

/*
 * Now, let's print it as a JSON string.
 */
char *str = bson_as_json (b, NULL);
printf ("%s\n", str);
bson_free (str);
]]></code></screen>

      <p>See the <link href="http://api.mongodb.org/libbson/current/bson_t.html">libbson documentation</link> for all of the types you can append to a <code>bson_t</code>.</p>
    </section>

    <section id="bcon">
      <title>Using BCON</title>
      <p>The imperative model for creating documents is time-consuming, verbose and can be prone to error. As an alternative, you can use <strong>BSON C Object Notation</strong> (or BCON for short) as a way to create documents that look much closer to the actual document format you are trying to create. Although there is less type safety than the typical imperative code, BCON can make for much cleaner C code.</p>
      <p>Note that using BCON has some overhead, but it is rare for BSON document creation to cause bottlenecks in code.</p>
      <p>Here is an example:</p>

      <screen><code><![CDATA[#include <bcon.h>
#include <bson.h>
#include <stdio.h>

int
main (int   argc,
      char *argv[])
{
   bson_t *doc;

   doc = BCON_NEW ("name", BCON_UTF8 ("Babe Ruth"),
                   "statistics", "{",
                      "batting_average", BCON_DOUBLE (.342),
                      "hits", BCON_INT32 (2873),
                      "home_runs", BCON_INT32 (714),
                      "rbi", BCON_INT32 (2213),
                   "}",
                   "nicknames", "[",
                      BCON_UTF8 ("the Sultan of Swat"),
                      BCON_UTF8 ("the Bambino"),
                   "]");

   str = bson_as_json (doc, NULL);
   printf ("%s\n", str);
   bson_free (str);

   bson_destroy (doc);

   return EXIT_SUCCESS;
}
]]></code></screen>

      <p>Notice that you can create arrays, subdocuments and arbitrary fields.</p>
    </section>
  </section>

  <section id="basic-operations">
    <title>Basic Operations</title>
    <p>This section demonstrates the basics of using the C Driver to interact with MongoDB. The examples all assume that a <code>mongod</code> is running on <code>localhost</code> on the default port.</p>

    <section id="insert-and-find">
      <title>Inserting and Finding a Document</title>
      <p>Now that we know how to get a handle on a database and collection, let's try inserting a document and querying it back. Here is a complete example:</p>

      <screen><code><![CDATA[#include <bcon.h>
#include <bson.h>
#include <mongoc.h>
#include <stdio.h>
#include <stdlib.h>

int
main (int   argc,
      char *argv[])
{
   bool                 r;
   bson_error_t         error;
   bson_oid_t           oid;
   bson_t              *doc;
   bson_t              *query;
   char                *str;
   const bson_t        *item;
   mongoc_client_t     *client;
   mongoc_collection_t *collection;
   mongoc_cursor_t     *cursor;

   mongoc_init ();

   /* Get a handle to our collection. */
   client = mongoc_client_new ("mongodb://localhost:27017");
   collection = mongoc_client_get_collection (client, "test", "test");

   /* Insert a document into the test collection. */
   bson_oid_init (&oid, NULL);
   doc = BCON_NEW ("_id", BCON_OID (&oid),
                   "hello", BCON_UTF8 ("world!"));
   r = mongoc_collection_insert (collection, MONGOC_INSERT_NONE, doc, NULL, &error);
   if (!r) {
      fprintf (stderr, "%s\n", error.message);
      return EXIT_FAILURE;
   }

   /* Build a query to execute */
   query = BCON_NEW ("_id", BCON_OID (&oid));

   /* Execute the query and iterate the results */
   cursor = mongoc_collection_find (collection, MONGOC_QUERY_NONE, 0, 0, 0, query, NULL, NULL);
   while (mongoc_cursor_next (cursor, &item)) {
      str = bson_as_json (item, NULL);
      printf ("%s\n", str);
      bson_free (str);
   }

   /* Perform cleanup */
   mongoc_cursor_destroy (cursor);
   mongoc_collection_destroy (collection);
   mongoc_client_destroy (client);
   bson_destroy (query);
   bson_destroy (doc);

   return EXIT_SUCCESS;
}
]]></code></screen>
    </section>

    <section id="counting">
      <title>Counting Documents</title>
      <p>To count the number of documents in a collection, we need to build a query selector. An empty query selector will count all documents in a collection.</p>

      <screen><code><![CDATA[#include <bson.h>
#include <mongoc.h>
#include <stdio.h>
#include <stdlib.h>

int
main (int argc,
      char *argv[])
{
   mongoc_collection_t *collection;
   mongoc_client_t *client;
   bson_error_t error;
   int64_t count;
   bson_t query;
   bool r;

   mongoc_init ();

   /* Get a handle to our collection */
   client = mongoc_client_new ("mongodb://localhost:27017");
   collection = mongoc_client_get_collection (client, "test", "test");

   /* Count all documents matching {"hello" : "world!"} */
   bson_init (&query);
   BSON_APPEND_UTF8 (&query, "hello", "world!");
   count = mongoc_collection_count (collection, MONGOC_QUERY_NONE, &query, 0, 0, NULL, &error);
   if (count < 0) {
      fprintf (stderr, "%s\n", error.message);
      return EXIT_FAILURE;
   }

   printf ("Found %"PRId64" documents in %s\n",
           count,
           mongoc_collection_get_name (collection));

   /* Release everything */
   mongoc_collection_destroy (collection);
   mongoc_client_destroy (client);
   bson_destroy (&query);

   return EXIT_SUCCESS;
}
]]></code></screen>
    </section>
  </section>

  <section id="threading">
    <title>Threading</title>
    <p>The MongoDB C Driver is thread-unaware in the vast majority of its operations. This means it is up to the programmer to guarantee thread-safety.</p>
    <p>However, <link xref="mongoc_client_pool_t">mongoc_client_pool_t</link> is thread-safe and is used to fetch a <code>mongoc_client_t</code> in a thread-safe manner. After retrieving a client from the pool, the client structure should be considered owned by the calling thread. When the thread is finished, it should be placed back into the pool.</p>
    
    <screen><code><![CDATA[#include <mongoc.h>
#include <pthread.h>

#define N_THREADS 10

static void *
worker (void *data) {
   mongoc_client_pool_t *pool = data;
   mongoc_client_t      *client;

   client = mongoc_client_pool_pop (pool);
   
   /* Do something... */

   mongoc_client_pool_push (pool, client);

   return NULL;
}

int
main (int   argc,
      char *argv[])
{
   mongoc_client_pool_t *pool;
   mongoc_uri_t         *uri;
   pthread_t             threads[N_THREADS];

   mongoc_init ();

   uri = mongoc_uri_new ("mongodb://localhost/");
   pool = mongoc_client_pool_new (uri);

   for (i = 0; i < N_THREADS; i++) {
      pthread_create (&threads[i], NULL, worker, pool);
   }

   for (i = 0; i < N_THREADS; i++) {
      pthread_join (threads[i], NULL);
   }

   mongoc_client_pool_destroy (pool);
   mongoc_uri_destroy (uri);

   return EXIT_SUCCESS;
}
]]></code></screen>
  </section>

  <section id="executing-commands">
    <title>Executing Commands</title>
    <p>The driver provides helper functions that make it easy to execute MongoDB commands. There are helpers for executing commands against client, database and collection structures, which return cursors. Alternatively, you can use the <code>_simple()</code> variant of each if you do not need a cursor back from the result. This is convenient for commands that return a single document.</p>
    <p>Here is an example that performs a simple ping command:</p>

    <screen><code><![CDATA[#include <bcon.h>
#include <bson.h>
#include <mongoc.h>
#include <stdio.h>

int
main (int   argc,
      char *argv[])
{
   mongoc_client_t *client;
   bson_t *command;
   bson_t reply;
   char *str;
   bool r;

   mongoc_init ();

   client = mongoc_client_new ("mongodb://localhost:27017/");
   command = BCON_NEW ("ping", BCON_INT32 (1));

   r = mongoc_client_command_simple (client, "admin", command, NULL, &reply, &error);
   if (!r) {
      fprintf (stderr, "%s\n", error.message);
      return EXIT_FAILURE;
   }

   str = bson_as_json (&reply, NULL);
   printf ("%s\n", str);
   bson_free (str);

   bson_destroy (&reply);
   bson_destroy (command);
   mongoc_client_destroy (client);

   return EXIT_SUCCESS;
}
]]></code></screen>
  </section>
</page>
